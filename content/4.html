<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>浮动和清除浮动</title>
	<link rel="stylesheet" href="main.css">
</head>
<body>
	<div class="container">
		<div class="header"><h1>浮动和清除浮动</h1>
			<div class="links">
				<a href="../index.html" class="returnMain">首页</a>
				<a href="3.html" class="pre">上一篇</a>
				<a href="5.html" class="next">下一篇</a>
			</div>
		</div>
		<div class="context">
			<p>&nbsp;&nbsp;每次看完浮动相关的知识，当时懂了，过了段时间又记得不清楚了。所以今天就把网上的知识点汇总下，以便经常看。</p>
			&nbsp;&nbsp;首先，浮动最初设计的目的是用来实现文字环绕效果而已，浮动元素会脱离文档流并向左/向右浮动，直到碰到父元素或者另一个浮动元素。
			<br>
			浮动元素引起的问题：
				<br>&nbsp;&nbsp;父元素的高度无法被撑开，影响与父元素同级的元素
				<br>&nbsp;&nbsp;与浮动元素同级的非浮动元素（内联元素）会跟随其后
			比较理想的解决方案;
			<pre>
				<code>
		css:
			.cf:before,.cf:after {
				content:"";
				display:table;
			}
			.cf:after { clear:both; }/* For IE 6/7 (trigger hasLayout) */
			.cf { zoom:1; }
				</code>
			
			</pre>
			<div>注：before伪元素是用来处理 margin 边距重叠的，由于内部元素 float 创建了BFC，导致内部元素的margin-top和 上一个盒子的 margin-bottom 发生叠加。如果这不是你所希望的，那么就可以加上 before，如果只是单纯的闭合浮动，after 就够了！</div>
			<br>
			具体到原理方面，什么BFC，Layout等不是我所能描叙清楚的，以下copy自一丝大神：那些年我们清除过的浮动：
<br><br><div><strong>（一）</strong>
	CSS中的定位机制：普通流，浮动，绝对定位 （其中"position:fixed" 是 "position:absolute" 的一个子类）。
	<br><p>1）普通流：很多人或者文章称之为文档流或者普通文档流，其实标准里根本就没有这个词。如果把文档流直译为英文就是 document flow ，但标准里只有另一个词，叫做 普通流 （normal flow)，或者称之为常规流。但似乎大家更习惯文档流的称呼，因为很多中文翻译的书就是这么来的。比如《CSS Mastery》，英文原书中至始至终都只有普通流 normal flow（普通流） 这一词，从来没出现过document flow （文档流）</p>
	<br><p>2）浮动：浮动的框可以左右移动，直至它的外边缘遇到包含框或者另一个浮动框的边缘。浮动框不属于文档中的普通流，当一个元素浮动之后，不会影响到块级框的布局而只会影响内联框（通常是文本）的排列，文档中的普通流就会表现得和浮动框不存在一样，当浮动框高度超出包含框的时候，也就会出现包含框不会自动伸高来闭合浮动元素（“高度塌陷”现象）。顾名思义，就是漂浮于普通流之上，像浮云一样，但是只能左右浮动。</p>
	<br><p>正是因为浮动的这种特性，导致本属于普通流中的元素浮动之后，包含框内部由于不存在其他普通流元素了，也就表现出高度为0（高度塌陷）。在实际布局中，往往这并不是我们所希望的，所以需要闭合浮动元素，使其包含框表现出正常的高度。</p>
</div>
	<br><div><p> <strong>（二）</strong>在CSS2.1里面有一个很重要的概念，但是国内的技术博客介绍到的比较少，那就是 Block Formatting Contexts（块级格式化上下文），以下简称 BFC。</p>
	&nbsp;&nbsp;&nbsp;&nbsp;CSS3里面对这个规范做了改动，称之为：flow root，并且对触发条件进行了进一步说明。那么如何触发BFC呢？
	<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、float 除了none以外的值
	<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、overflow 除了visible 以外的值（hidden，auto，scroll ）
	<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、display (table-cell，table-caption，inline-block)
	<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、position（absolute，fixed）
	<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5、fieldset元素
	<br>需要注意的是，display:table 本身并不会创建BFC，但是它会产生匿名框(anonymous boxes)，而匿名框中的display:table-cell可以创建新的BFC，换句话说，触发块级格式化上下文的是匿名框，而不是display:table。所以通过display:table和display:table-cell创建的BFC效果是不一样的。
</div>
<br><div><p>  <strong>（三）</strong>
BFC的特性：
　　<br>1) 块级格式化上下文会阻止外边距叠加
　　<br>&nbsp;&nbsp;&nbsp;&nbsp;当两个相邻的块框在同一个块级格式化上下文中时，它们之间垂直方向的外边距会发生叠加。换句话说，如果这两个相邻的块框不属于同一个块级格式化上下文，那么它们的外边距就不会叠加。
　　<br>2) 块级格式化上下文不会重叠浮动元素
　　<br>&nbsp;&nbsp;&nbsp;&nbsp;根据规定，一个块级格式化上下文的边框不能和它里面的元素的外边距重叠。这就意味着浏览器将会给块级格式化上下文创建隐式的外边距来阻止它和浮动元素的外边距叠加。由于这个原因，当给一个挨着浮动的块级格式化上下文添加负的外边距时将会不起作用（Webkit和IE6在这点上有一个问题——可以看这个测试用例）。
　　<br>3) 块级格式化上下文通常可以包含浮动
　　<br>&nbsp;&nbsp;&nbsp;&nbsp;详见： W3C CSS2.1 - 10.6.7 'Auto' heights for block formatting context roots
　　<br>&nbsp;&nbsp;&nbsp;&nbsp;通俗地来说：创建了 BFC的元素就是一个独立的盒子，里面的子元素不会在布局上影响外面的元素，反之亦然，同时BFC任然属于文档中的普通流。
</div>

　　至此，您或许明白了为什么 overflow:hidden或者auto可以闭合浮动了，真是因为父元素创建了新的BFC。
<br><br><div><p>  <strong>（四）</strong>IE6-7的显示引擎使用的是一个称为布局（layout）的内部概念，由于这个显示引擎自身存在很多的缺陷，直接导致了IE6-7的很多显示bug。当我们说一个元素“得到 layout”，或者说一个元素“拥有 layout” 的时候，我们的意思是指它的微软专有属性 hasLayout http://msdn.microsoft.com/works... 为此被设为了 true 。IE6-7使用布局的概念来控制元素的尺寸和定位，那些拥有布局（have layout）的元素负责本身及其子元素的尺寸设置和定位。如果一个元素的 hasLayout 为false，那么它的尺寸和位置由最近拥有布局的祖先元素控制。
　　<br>触发hasLayout的条件：
　　<br>&nbsp;&nbsp;&nbsp;&nbsp;position: absolute
　　<br>&nbsp;&nbsp;&nbsp;&nbsp;float: left|right
　　<br>&nbsp;&nbsp;&nbsp;&nbsp;display: inline-block
　　<br>&nbsp;&nbsp;&nbsp;&nbsp;width: 除 “auto” 外的任意值
　　<br>&nbsp;&nbsp;&nbsp;&nbsp;height: 除 “auto” 外的任意值 （例如很多人闭合浮动会用到 height: 1% ）
　　<br>&nbsp;&nbsp;&nbsp;&nbsp;zoom: 除 “normal” 外的任意值 (MSDN) 
　　<br>&nbsp;&nbsp;&nbsp;&nbsp;writing-mode: tb-rl (MSDN) 
　　<br>在 IE7 中，overflow 也变成了一个 layout 触发器：
　　<br>&nbsp;&nbsp;&nbsp;&nbsp;overflow: hidden|scroll|auto （ 这个属性在IE之前版本中没有触发 layout 的功能。 ）
　　<br><br>IE8使用了全新的渲染引擎，删除了 hasLayout 原本的功能，因此彻底杜绝了很多深恶痛绝的 bug，但 IE8~IE11 通过「document.documentElement.currentStyle.hasLayout」依然可以获得 hasLayout 的标志。
</div><br>
　　综上所述：
<br>
　　在支持BFC的浏览器（IE8+，firefox，chrome，safari）通过创建新的BFC闭合浮动；
<br>
　　在不支持 BFC的浏览器 （IE6-7），通过触发 hasLayout 闭合浮动。
<br><br><div><p>  <strong>（四）闭合浮动</strong></p>
我们发现其实更多的：display：table-cell，display：inline-block等只要触发了BFC的属性值都可以闭合浮动。从各个方面比较，after伪元素闭合浮动无疑是相对比较好的解决方案了，下面详细说说该方法。
			<pre>
				<code>
		.clearfix:after {content:"."; display:block; height:0; visibility:hidden; clear:both; }
		.clearfix { *zoom:1; }
				</code>
			</pre>
<div>
	<br>1) display:block 使生成的元素以块级元素显示,占满剩余空间;
　　<br>2) height:0 避免生成内容破坏原有布局的高度。
　　<br>3) visibility:hidden 使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互;
　　<br>4）通过 content:"."生成内容作为最后一个元素，至于content里面是点还是其他都是可以的，例如oocss里面就有经典的content:"XXXXXXXXX",有些版本可能content 里面内容为空,一丝冰凉是不推荐这样做的,firefox直到7.0 content:”" 仍然会产生额外的空隙；
　　<br>5）zoom：1 触发IE hasLayout。
　　<br>通过分析发现，除了clear：both用来闭合浮动的，其他代码无非都是为了隐藏掉content生成的内容，这也就是其他版本的闭合浮动为什么会有font-size：0，line-height：0。
</div>
			<br><br>
			<p>参考博客：</p>
			<p>http://www.cnblogs.com/lhb25/p/story-of-clear-float.html</p>
			<p>http://www.jianshu.com/p/09bd5873bed4</p>

		</div>
		<div class="footer">Copyright © 2016 </div>
	</div>
</body> 
</html>